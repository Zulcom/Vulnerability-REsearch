# [BRLY-2022-054]

# Stack buffer overflow vulnerability leads to arbitrary code execution in DXE driver on multiple Dell platforms.

## Summary

**BINARLY efiXplorer team** has discovered a stack overflow vulnerability that allows a potential attacker to access UEFI DXE driver and execute arbitrary code.

## Vulnerability Information

* BINARLY internal vulnerability identifier: BRLY-2022-054
* Dell PSIRT assigned CVE identifier: CVE-2023-28036
* DSA identifier: [DSA-2023-099](https://www.dell.com/support/kbdoc/en-us/000212204/dsa-2023-099-dell-client-bios-security-update-for-multiple-improper-input-validation-vulnerabilities)/[DSA-2023-204](https://www.dell.com/support/kbdoc/en-us/000214910/dsa-2023-204-security-update-for-dell-poweredge-t30-t40-mini-tower-server-for-multiple-memory-leak-vulnerability)
* CVSS v3.1: 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H

## Affected Dell firmware with confirmed impact by Binarly team

| Product | Firmware version | CPU | Module name | Module GUID | Module SHA256 |
| --- | --- | --- | --- | --- | --- |
| Latitude 9520 | 0.1.17.0 | Intel | Setup | e6a7a1ce-5881-4b49-80be-69c91811685c | 3d3150a82da8f1e143f85bfe50d894a735886c243b3dd93209b1346ad200c054 |
| Inspiron 15 3511, Vostro 15 3510 | 0.1.18.2 | Intel | Setup | e6a7a1ce-5881-4b49-80be-69c91811685c | 85d1e1cf6f5175d22ab262bc5034720287bfaf54e5a1b9074e624b106f627808 |
| XPS 13 9365 | 0.2.24.0 | Intel | Setup | e6a7a1ce-5881-4b49-80be-69c91811685c | befd809dc391328ad5553f72f6528c74c152fb51aef52738f2c7f5e10dcda3c4 |
| Latitude 3301 | 0.1.17.0 | Intel | Setup | e6a7a1ce-5881-4b49-80be-69c91811685c | e4f86398668c72865f121e2ff10136da190c9fc18b4835ff0426d8ccb504cb25 |
| OptiPlex 3000 Thin Client | 0.1.4.0 | Intel | Setup | e6a7a1ce-5881-4b49-80be-69c91811685c | eec811ee26817bbc8ead55742bb2a2b9c1cb1c87814a59646660203910ccfe2a |
| Latitude 5420 | 0.1.22.0 | Intel | Setup | e6a7a1ce-5881-4b49-80be-69c91811685c | fd097b2327a983291c443da05b5f588491de06a3aa212c98a5f4bb8046241784 |


## Potential impact

An attacker with high local access can exploit this vulnerability to elevate privileges from ring 3 or ring 0 (depends on the operating system) to a DXE driver and execute arbitrary code. Malicious code installed as a result of this exploitation could survive operating system (OS) boot process and runtime, or modify NVRAM area on the SPI flash storage (to gain persistence). Additionally, threat actors could use this vulnerability to bypass OS security mechanisms (modify privileged memory or runtime variables), influence OS boot process, and in some cases allow an attacker to hook or modify EFI Runtime services.

## Vulnerability description

Let's take Latitude 9520's firmware (version: 0.1.17.0, module sha256: 3d3150a82da8f1e143f85bfe50d894a735886c243b3dd93209b1346ad200c054) as an example.

The following code in the module actually allows to overflow a stack buffer:

* a call to a `gRT->GetVariable()` offset: `0xb2ad`
* a call to a `gRT->GetVariable()` offset: `0xb2d5`

```c++
char sub_B220()
{
  __int64 v0; // rbx
  char result; // al
  char v2; // dl
  unsigned __int8 v3; // bl
  char v4; // dl
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  unsigned __int8 v8; // bl
  char v9; // dl
  void *Interface; // [rsp+30h] [rbp-40h] BYREF
  __int64 Data; // [rsp+38h] [rbp-38h] BYREF
  __int64 v12; // [rsp+40h] [rbp-30h]
  char v13[8]; // [rsp+48h] [rbp-28h]
  __int64 v14; // [rsp+50h] [rbp-20h] BYREF
  __int64 v15; // [rsp+58h] [rbp-18h]
  char v16; // [rsp+60h] [rbp-10h]
  int v17; // [rsp+90h] [rbp+20h] BYREF
  UINTN DataSize; // [rsp+98h] [rbp+28h] BYREF
  int v19; // [rsp+A0h] [rbp+30h] BYREF
  __int16 v20; // [rsp+A4h] [rbp+34h]
  char v21; // [rsp+A6h] [rbp+36h]
  void *HeciProtocol; // [rsp+A8h] [rbp+38h] BYREF

  Data = 0i64;
  v12 = 0i64;
  v13[0] = 0;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v0 = gBS->LocateProtocol(&HECI_PROTOCOL_GUID, 0i64, &Interface);
  result = sub_FF2C();
  if ( !result && v0 >= 0 )
  {
    DataSize = 17i64;
    gRT->GetVariable(                           // <= first call (we can rewrite DataSize here)
      L"MeSetupStorage",
      &ME_SETUP_VARIABLE_GUID,
      0i64,
      &DataSize,
      &Data);
    gRT->GetVariable(                           // <= second call
      L"MeBackupStorage",
      &ME_SETUP_VARIABLE_GUID,
      0i64,
      &DataSize,
      &v14);
    DataSize = 143i64;
    gRT->GetVariable(L"MeSetup", &ME_SETUP_VARIABLE_GUID, 0i64, &DataSize, &unk_A0F80);
    DataSize = 7i64;
    gRT->GetVariable(L"TcgSetup", &EFI_SETUP_VARIABLE_GUID, 0i64, &DataSize, &v19);
    if ( BYTE4(v12) != BYTE4(v15) && !byte_A0FAA && BYTE4(v12) == 1 )
      sub_F120();
    if ( BYTE2(Data) != BYTE2(v14) )
    {
      byte_A0891 = 1;
      if ( BYTE2(Data) )
      {
        sub_F320();
      }
      else if ( (gBS->LocateProtocol(&HECI_PROTOCOL_GUID, 0i64, &HeciProtocol) & 0x8000000000000000ui64) == 0i64 )
      {
        (*(HeciProtocol + 8))(&v17);
        if ( v17 != 3 && !sub_FF2C() )
          sub_ED6C(6, v2, 0);
      }
    }
    v3 = BYTE1(Data);
    if ( BYTE1(Data) != BYTE1(v14) && !sub_FF2C() )
      sub_ED6C(7, v4, v3);
    if ( Data != v14 )
    {
      byte_A0891 = 1;
      if ( Data == 1 )
      {
        v5 = 4;
        v6 = 0;
      }
      else
      {
        v5 = 0;
        v6 = 4;
      }
      sub_F414(v5, v6);
    }
    v7 = byte_A0891;
    v8 = BYTE6(Data);
    if ( BYTE5(Data) != BYTE5(v14) )
      v7 = 1;
    byte_A0891 = v7;
    if ( BYTE6(Data) != BYTE6(v14) && v19 == 1 && !sub_FF2C() )
      sub_ED6C(47, v9, v8);
    LOBYTE(v7) = BYTE2(v12);
    if ( BYTE2(v12) != BYTE2(v15) )
    {
      byte_A0891 = 1;
      sub_EF84(SBYTE2(v12));
    }
    if ( BYTE3(v12) != BYTE3(v15) )
      sub_F5C0(BYTE3(v12));
    if ( HIBYTE(v12) != HIBYTE(v15) )
      sub_FBAC(v7, SHIBYTE(v12));
    if ( v13[0] != v16 )
      sub_FD30(v7, v13[0]);
    return gRT->SetVariable(L"MeBackupStorage", &ME_SETUP_VARIABLE_GUID, 2u, 0x11ui64, &Data);
  }
  return result;
}
```

The `DataSize` is initialized only once (before the first call to `gRT->GetVariable()` service).

If the length of `MeSetupStorage` NVRAM variable is greater than `17`, the second call to `gRT->GetVariable()` service will overflow a stack buffer, which in turn could lead to arbitrary code execution.

To fix this vulnerability the `DataSize` must be re-initialized with the size of `MeBackupStorage` before calling `gRT->GetVariable()`.

## Disclosure timeline

This bug is subject to a 90 day disclosure deadline. After 90 days elapsed or a patch has been made broadly available (whichever is earlier), the bug report will become visible to the public.

| Disclosure Activity | Date (YYYY-mm-dd) |
| --- | --- |
| Dell PSIRT is notified | 2022-12-29 |
| Dell PSIRT confirmed reported issue | 2023-03-16 |
| Dell PSIRT assigned CVE number | 2023-06-15 |
| Dell PSIRT provide patch release | 2023-06-15 |
| BINARLY public disclosure date | 2023-06-21 |

## Acknowledgements

**BINARLY efiXplorer team**
